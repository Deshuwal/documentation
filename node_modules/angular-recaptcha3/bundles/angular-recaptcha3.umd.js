(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/forms'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('angular-recaptcha3', ['exports', '@angular/common', '@angular/core', '@angular/forms', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['angular-recaptcha3'] = {}, global.ng.common, global.ng.core, global.ng.forms, global.rxjs, global.rxjs.operators));
}(this, (function (exports, common, core, forms, rxjs, operators) { 'use strict';

    var RECAPTCHA_OPTION = new core.InjectionToken('RECAPTCHA_OPTION');

    /*
     * Common service shared by all reCaptcha component instances
     * through dependency injection.
     * This service has the task of loading the reCaptcha API once for all.
     * Only the first instance of the component creates the service, subsequent
     * components will use the existing instance.
     *
     * As the language is passed to the <script>, the first component
     * determines the language of all subsequent components. This is a limitation
     * of the present Google API.
     */
    var ReCaptchaService = /** @class */ (function () {
        function ReCaptchaService(zone) {
            var _this = this;
            this.scriptLoaded = false;
            this.readySubject = new rxjs.BehaviorSubject(false);
            /* the callback needs to exist before the API is loaded */
            if (typeof window !== 'undefined') {
                window['reCaptchaOnloadCallback'] = (function () {
                    zone.run(_this.onloadCallback.bind(_this));
                });
            }
        }
        ReCaptchaService.prototype.getReady = function (language) {
            if (!this.scriptLoaded) {
                this.scriptLoaded = true;
                var doc = document.body;
                var script = document.createElement('script');
                script.innerHTML = '';
                script.src = 'https://www.google.com/recaptcha/api.js?onload=reCaptchaOnloadCallback&render=explicit' +
                    (language ? '&hl=' + language : '');
                script.async = true;
                script.defer = true;
                doc.appendChild(script);
            }
            return this.readySubject.asObservable();
        };
        ReCaptchaService.prototype.execute = function (options) {
            if (options === void 0) { options = undefined; }
            var captcha = window.grecaptcha;
            var captchaElement = document.querySelector('.g-recaptcha.invisible');
            return captcha.execute(captchaElement.id, options);
        };
        ReCaptchaService.prototype.onloadCallback = function () {
            this.readySubject.next(true);
        };
        return ReCaptchaService;
    }());
    ReCaptchaService.decorators = [
        { type: core.Injectable }
    ];
    ReCaptchaService.ctorParameters = function () { return [
        { type: core.NgZone }
    ]; };
    /* singleton pattern taken from https://github.com/angular/angular/issues/13854 */
    function RECAPTCHA_SERVICE_PROVIDER_FACTORY(ngZone, parentDispatcher) {
        return parentDispatcher || new ReCaptchaService(ngZone);
    }
    var RECAPTCHA_SERVICE_PROVIDER = {
        provide: ReCaptchaService,
        deps: [core.NgZone, [new core.Optional(), new core.SkipSelf(), ReCaptchaService]],
        useFactory: RECAPTCHA_SERVICE_PROVIDER_FACTORY
    };

    var ReCaptchaComponent = /** @class */ (function () {
        function ReCaptchaComponent(_zone, _captchaService, option) {
            this._zone = _zone;
            this._captchaService = _captchaService;
            this.option = option;
            this.hide = true;
            this.captchaResponse = new core.EventEmitter();
            this.captchaExpired = new core.EventEmitter();
            this.widgetId = null;
            this.ngUnsubscribe = new rxjs.Subject();
            this.onChange = function () { };
            this.onTouched = function () { };
            option = option || {
                language: 'ru',
                invisible: {
                    sitekey: this.sitekey || undefined,
                    theme: 'light',
                    type: 'image',
                    tabindex: 0,
                    badge: 'bottomright'
                },
            };
        }
        ReCaptchaComponent.prototype.ngAfterViewInit = function () {
            this.setWidgetId();
        };
        ReCaptchaComponent.prototype.reset = function () {
            if (this.widgetId === null) {
                return;
            }
            this.grecaptchaReset();
            this.onChange(null);
        };
        ReCaptchaComponent.prototype.setWidgetId = function () {
            var _this = this;
            this._captchaService.getReady(this.language || this.option.language)
                .pipe(operators.takeUntil(this.ngUnsubscribe))
                .subscribe(function (ready) {
                if (!ready) {
                    return;
                }
                _this.widgetId = _this.render(_this.targetRef.nativeElement);
            });
        };
        ReCaptchaComponent.prototype.render = function (target) {
            var _this = this;
            return window.grecaptcha.render(target, {
                'sitekey': this.getSiteKey(),
                'badge': this.getBadge(),
                'theme': this.getTheme(),
                'type': this.getType(),
                'tabindex': this.getTabindex(),
                'size': this.size || 'invisible',
                'callback': (function (response) { return _this._zone.run(_this.recaptchaCallback.bind(_this, response)); }),
                'expired-callback': (function () { return _this._zone.run(_this.recaptchaExpiredCallback.bind(_this)); })
            });
        };
        ReCaptchaComponent.prototype.execute = function (options) {
            if (options === void 0) { options = undefined; }
            if (this.size !== 'invisible') {
                return;
            }
            if (this.widgetId === null) {
                throw new Error('Invalid widgetId');
            }
            return window.grecaptcha.execute(this.widgetId, options);
        };
        ReCaptchaComponent.prototype.getResponse = function () {
            if (this.widgetId === null) {
                throw new Error('Invalid widgetId');
            }
            return window.grecaptcha.getResponse(this.widgetId);
        };
        ReCaptchaComponent.prototype.writeValue = function (newValue) {
            /* ignore it */
        };
        ReCaptchaComponent.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        ReCaptchaComponent.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        ReCaptchaComponent.prototype.ngOnDestroy = function () {
            this.grecaptchaReset();
            this.ngUnsubscribe.next();
            this.ngUnsubscribe.complete();
        };
        ReCaptchaComponent.prototype.recaptchaCallback = function (response) {
            this.onChange(response);
            this.onTouched();
            this.captchaResponse.emit(response);
        };
        ReCaptchaComponent.prototype.recaptchaExpiredCallback = function () {
            this.onChange(null);
            this.onTouched();
            this.captchaExpired.emit();
        };
        ReCaptchaComponent.prototype.grecaptchaReset = function () {
            var _this = this;
            if (this.widgetId != null) {
                this._zone.runOutsideAngular(function () { return window.grecaptcha.reset(_this.widgetId); });
            }
        };
        ReCaptchaComponent.prototype.getSiteKey = function () {
            if (this.sitekey) {
                return this.sitekey;
            }
            if (this.size === 'invisible') {
                return this.option.invisible.sitekey;
            }
            if (this.size === 'normal') {
                return this.option.normal.sitekey;
            }
            throw new Error('Invalid sitekey');
        };
        ReCaptchaComponent.prototype.getBadge = function () {
            if (this.badge) {
                return this.badge;
            }
            if (this.size === 'invisible') {
                return this.option.invisible.badge;
            }
            if (this.size === 'normal') {
                return this.option.normal.badge;
            }
            return 'bottomright';
        };
        ReCaptchaComponent.prototype.getTheme = function () {
            if (this.theme) {
                return this.theme;
            }
            if (this.size === 'invisible') {
                return this.option.invisible.theme;
            }
            if (this.size === 'normal') {
                return this.option.normal.theme;
            }
            return 'light';
        };
        ReCaptchaComponent.prototype.getType = function () {
            if (this.type) {
                return this.type;
            }
            if (this.size === 'invisible') {
                return this.option.invisible.type;
            }
            if (this.size === 'normal') {
                return this.option.normal.type;
            }
            return 'image';
        };
        ReCaptchaComponent.prototype.getTabindex = function () {
            if (this.tabindex) {
                return this.tabindex;
            }
            if (this.size === 'invisible') {
                return this.option.invisible.tabindex;
            }
            if (this.size === 'normal') {
                return this.option.normal.tabindex;
            }
            return 0;
        };
        return ReCaptchaComponent;
    }());
    ReCaptchaComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'recaptcha',
                    template: "\n        <div #target\n            [ngClass]=\"{'hide': hide}\"\n            [class]=\"'recaptcha g-recaptcha ' + (size || 'invisible')\"\n            [id]=\"widgetId\">\n        </div>\n    ",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: core.forwardRef(function () { return ReCaptchaComponent; }),
                            multi: true
                        }
                    ],
                    styles: ["\n        .hide {\n            display: none;\n        }\n    "]
                },] },
        { type: core.Injectable }
    ];
    ReCaptchaComponent.ctorParameters = function () { return [
        { type: core.NgZone },
        { type: ReCaptchaService },
        { type: undefined, decorators: [{ type: core.Inject, args: [RECAPTCHA_OPTION,] }] }
    ]; };
    ReCaptchaComponent.propDecorators = {
        sitekey: [{ type: core.Input }],
        size: [{ type: core.Input }],
        theme: [{ type: core.Input }],
        type: [{ type: core.Input }],
        tabindex: [{ type: core.Input }],
        badge: [{ type: core.Input }],
        language: [{ type: core.Input }],
        hide: [{ type: core.Input }],
        captchaResponse: [{ type: core.Output }],
        captchaExpired: [{ type: core.Output }],
        targetRef: [{ type: core.ViewChild, args: ['target',] }]
    };

    var ReCaptchaModule = /** @class */ (function () {
        function ReCaptchaModule() {
        }
        ReCaptchaModule.forRoot = function (option) {
            if (option === void 0) { option = undefined; }
            return {
                ngModule: ReCaptchaModule,
                providers: [
                    {
                        provide: RECAPTCHA_OPTION,
                        useValue: option
                    }
                ]
            };
        };
        return ReCaptchaModule;
    }());
    ReCaptchaModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [ReCaptchaComponent],
                    exports: [ReCaptchaComponent],
                    providers: [RECAPTCHA_SERVICE_PROVIDER]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.RECAPTCHA_OPTION = RECAPTCHA_OPTION;
    exports.RECAPTCHA_SERVICE_PROVIDER = RECAPTCHA_SERVICE_PROVIDER;
    exports.RECAPTCHA_SERVICE_PROVIDER_FACTORY = RECAPTCHA_SERVICE_PROVIDER_FACTORY;
    exports.ReCaptchaComponent = ReCaptchaComponent;
    exports.ReCaptchaModule = ReCaptchaModule;
    exports.ReCaptchaService = ReCaptchaService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-recaptcha3.umd.js.map
