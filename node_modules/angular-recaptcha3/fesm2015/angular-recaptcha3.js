import { CommonModule } from '@angular/common';
import { InjectionToken, Injectable, NgZone, Optional, SkipSelf, EventEmitter, Component, forwardRef, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

const RECAPTCHA_OPTION = new InjectionToken('RECAPTCHA_OPTION');

/*
 * Common service shared by all reCaptcha component instances
 * through dependency injection.
 * This service has the task of loading the reCaptcha API once for all.
 * Only the first instance of the component creates the service, subsequent
 * components will use the existing instance.
 *
 * As the language is passed to the <script>, the first component
 * determines the language of all subsequent components. This is a limitation
 * of the present Google API.
 */
class ReCaptchaService {
    constructor(zone) {
        this.scriptLoaded = false;
        this.readySubject = new BehaviorSubject(false);
        /* the callback needs to exist before the API is loaded */
        if (typeof window !== 'undefined') {
            window['reCaptchaOnloadCallback'] = (() => {
                zone.run(this.onloadCallback.bind(this));
            });
        }
    }
    getReady(language) {
        if (!this.scriptLoaded) {
            this.scriptLoaded = true;
            let doc = document.body;
            let script = document.createElement('script');
            script.innerHTML = '';
            script.src = 'https://www.google.com/recaptcha/api.js?onload=reCaptchaOnloadCallback&render=explicit' +
                (language ? '&hl=' + language : '');
            script.async = true;
            script.defer = true;
            doc.appendChild(script);
        }
        return this.readySubject.asObservable();
    }
    execute(options = undefined) {
        const captcha = window.grecaptcha;
        const captchaElement = document.querySelector('.g-recaptcha.invisible');
        return captcha.execute(captchaElement.id, options);
    }
    onloadCallback() {
        this.readySubject.next(true);
    }
}
ReCaptchaService.decorators = [
    { type: Injectable }
];
ReCaptchaService.ctorParameters = () => [
    { type: NgZone }
];
/* singleton pattern taken from https://github.com/angular/angular/issues/13854 */
function RECAPTCHA_SERVICE_PROVIDER_FACTORY(ngZone, parentDispatcher) {
    return parentDispatcher || new ReCaptchaService(ngZone);
}
const RECAPTCHA_SERVICE_PROVIDER = {
    provide: ReCaptchaService,
    deps: [NgZone, [new Optional(), new SkipSelf(), ReCaptchaService]],
    useFactory: RECAPTCHA_SERVICE_PROVIDER_FACTORY
};

class ReCaptchaComponent {
    constructor(_zone, _captchaService, option) {
        this._zone = _zone;
        this._captchaService = _captchaService;
        this.option = option;
        this.hide = true;
        this.captchaResponse = new EventEmitter();
        this.captchaExpired = new EventEmitter();
        this.widgetId = null;
        this.ngUnsubscribe = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
        option = option || {
            language: 'ru',
            invisible: {
                sitekey: this.sitekey || undefined,
                theme: 'light',
                type: 'image',
                tabindex: 0,
                badge: 'bottomright'
            },
        };
    }
    ngAfterViewInit() {
        this.setWidgetId();
    }
    reset() {
        if (this.widgetId === null) {
            return;
        }
        this.grecaptchaReset();
        this.onChange(null);
    }
    setWidgetId() {
        this._captchaService.getReady(this.language || this.option.language)
            .pipe(takeUntil(this.ngUnsubscribe))
            .subscribe((ready) => {
            if (!ready) {
                return;
            }
            this.widgetId = this.render(this.targetRef.nativeElement);
        });
    }
    render(target) {
        return window.grecaptcha.render(target, {
            'sitekey': this.getSiteKey(),
            'badge': this.getBadge(),
            'theme': this.getTheme(),
            'type': this.getType(),
            'tabindex': this.getTabindex(),
            'size': this.size || 'invisible',
            'callback': ((response) => this._zone.run(this.recaptchaCallback.bind(this, response))),
            'expired-callback': (() => this._zone.run(this.recaptchaExpiredCallback.bind(this)))
        });
    }
    execute(options = undefined) {
        if (this.size !== 'invisible') {
            return;
        }
        if (this.widgetId === null) {
            throw new Error('Invalid widgetId');
        }
        return window.grecaptcha.execute(this.widgetId, options);
    }
    getResponse() {
        if (this.widgetId === null) {
            throw new Error('Invalid widgetId');
        }
        return window.grecaptcha.getResponse(this.widgetId);
    }
    writeValue(newValue) {
        /* ignore it */
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    ngOnDestroy() {
        this.grecaptchaReset();
        this.ngUnsubscribe.next();
        this.ngUnsubscribe.complete();
    }
    recaptchaCallback(response) {
        this.onChange(response);
        this.onTouched();
        this.captchaResponse.emit(response);
    }
    recaptchaExpiredCallback() {
        this.onChange(null);
        this.onTouched();
        this.captchaExpired.emit();
    }
    grecaptchaReset() {
        if (this.widgetId != null) {
            this._zone.runOutsideAngular(() => window.grecaptcha.reset(this.widgetId));
        }
    }
    getSiteKey() {
        if (this.sitekey) {
            return this.sitekey;
        }
        if (this.size === 'invisible') {
            return this.option.invisible.sitekey;
        }
        if (this.size === 'normal') {
            return this.option.normal.sitekey;
        }
        throw new Error('Invalid sitekey');
    }
    getBadge() {
        if (this.badge) {
            return this.badge;
        }
        if (this.size === 'invisible') {
            return this.option.invisible.badge;
        }
        if (this.size === 'normal') {
            return this.option.normal.badge;
        }
        return 'bottomright';
    }
    getTheme() {
        if (this.theme) {
            return this.theme;
        }
        if (this.size === 'invisible') {
            return this.option.invisible.theme;
        }
        if (this.size === 'normal') {
            return this.option.normal.theme;
        }
        return 'light';
    }
    getType() {
        if (this.type) {
            return this.type;
        }
        if (this.size === 'invisible') {
            return this.option.invisible.type;
        }
        if (this.size === 'normal') {
            return this.option.normal.type;
        }
        return 'image';
    }
    getTabindex() {
        if (this.tabindex) {
            return this.tabindex;
        }
        if (this.size === 'invisible') {
            return this.option.invisible.tabindex;
        }
        if (this.size === 'normal') {
            return this.option.normal.tabindex;
        }
        return 0;
    }
}
ReCaptchaComponent.decorators = [
    { type: Component, args: [{
                selector: 'recaptcha',
                template: `
        <div #target
            [ngClass]="{'hide': hide}"
            [class]="'recaptcha g-recaptcha ' + (size || 'invisible')"
            [id]="widgetId">
        </div>
    `,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ReCaptchaComponent),
                        multi: true
                    }
                ],
                styles: [`
        .hide {
            display: none;
        }
    `]
            },] },
    { type: Injectable }
];
ReCaptchaComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ReCaptchaService },
    { type: undefined, decorators: [{ type: Inject, args: [RECAPTCHA_OPTION,] }] }
];
ReCaptchaComponent.propDecorators = {
    sitekey: [{ type: Input }],
    size: [{ type: Input }],
    theme: [{ type: Input }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    badge: [{ type: Input }],
    language: [{ type: Input }],
    hide: [{ type: Input }],
    captchaResponse: [{ type: Output }],
    captchaExpired: [{ type: Output }],
    targetRef: [{ type: ViewChild, args: ['target',] }]
};

class ReCaptchaModule {
    static forRoot(option = undefined) {
        return {
            ngModule: ReCaptchaModule,
            providers: [
                {
                    provide: RECAPTCHA_OPTION,
                    useValue: option
                }
            ]
        };
    }
}
ReCaptchaModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [ReCaptchaComponent],
                exports: [ReCaptchaComponent],
                providers: [RECAPTCHA_SERVICE_PROVIDER]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { RECAPTCHA_OPTION, RECAPTCHA_SERVICE_PROVIDER, RECAPTCHA_SERVICE_PROVIDER_FACTORY, ReCaptchaComponent, ReCaptchaModule, ReCaptchaService };
//# sourceMappingURL=angular-recaptcha3.js.map
