import { Component, ChangeDetectionStrategy, InjectionToken, ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, Inject, ElementRef, HostBinding, ContentChildren, NgModule } from '@angular/core';
import { __rest } from 'tslib';
import { Title, Meta } from '@angular/platform-browser';
import { Subject, combineLatest } from 'rxjs';
import { map, takeUntil } from 'rxjs/operators';

class NgHelmetTitleComponent {
}
NgHelmetTitleComponent.decorators = [
    { type: Component, args: [{
                selector: "ng-helmet > title",
                template: `<ng-content></ng-content>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];

class NgHelmetMetaComponent {
}
NgHelmetMetaComponent.decorators = [
    { type: Component, args: [{
                selector: "ng-helmet > meta",
                template: "",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];

function buildHelmet(titleEl, metaEls) {
    return Object.assign(Object.assign({}, (titleEl && { title: titleEl.nativeElement.text })), { metas: metaEls.map(metaToDefinition).reduce((acc, el) => {
            acc[attrSelector(el)] = el;
            return acc;
        }, {}) });
}
function metaToDefinition({ nativeElement: el, }) {
    const { name, content, httpEquiv } = el;
    const property = el.getAttribute("property");
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (name && { name })), (content && { content })), (httpEquiv && { httpEquiv })), (property && { property }));
}
function attrSelector(meta) {
    if (meta.name) {
        return `name='${meta.name}'`;
    }
    else if (meta.property) {
        return `property='${meta.property}'`;
    }
    throw new Error(`MetaDefinition does not have 'name' or 'property'`);
}

const NG_HELMET_CONFIG_TOKEN = new InjectionToken("ng-helmet.config");

class NgHelmetService {
    constructor(title, meta, config) {
        this.title = title;
        this.meta = meta;
        this.config = config;
        this.helmetStack = [];
    }
    /**
     * Push a new helmet on to the helmetStack and update the document head.
     * If the helmet id already exists in the stack (i.e. the ng-helmet content
     * was updated), this method simply updates the helmet at the existing position.
     * @param id The id of the NgHelmetComponent this helmet comes from.
     * @param helmet the NgHelmet data harvested from the component.
     */
    pushHelmet(id, helmet) {
        const index = this.helmetStack.findIndex((e) => e.id === id);
        if (index === -1) {
            this.helmetStack.push({ id, helmet });
        }
        else {
            this.helmetStack[index].helmet = helmet;
        }
        this.applyHelmet(this.computeHelmet());
    }
    /**
     * Pop the top element off the helmetStack and update the document head.
     */
    popHelmet() {
        const top = this.helmetStack.pop();
        if (top) {
            // Drop the content attribute from all top metas so they get cleared.
            const topMetas = top.helmet.metas;
            Object.keys(topMetas).forEach((selector) => {
                const _a = topMetas[selector], { content: _ } = _a, rest = __rest(_a, ["content"]);
                topMetas[selector] = rest;
            });
            // Merge top metas to clear with new computed metas.
            const { title, metas } = this.computeHelmet();
            this.applyHelmet({ title, metas: Object.assign(Object.assign({}, topMetas), metas) });
        }
        else {
            throw new Error(`popped an empty helmetStack`);
        }
    }
    /**
     * Compute the current helmet from the stack.
     * @returns The current helmet.
     */
    computeHelmet() {
        if (this.helmetStack.length > 0) {
            return this.helmetStack
                .map((e) => e.helmet)
                .reduce((acc, el) => {
                var _a;
                return ({
                    title: (_a = el.title) !== null && _a !== void 0 ? _a : acc.title,
                    metas: Object.assign(Object.assign({}, acc.metas), el.metas),
                });
            });
        }
        return { metas: {} };
    }
    /**
     * Apply the given helmet to the document header.
     * @param helmet The helmet to apply.
     */
    applyHelmet(helmet) {
        var _a;
        if (helmet.title) {
            const baseTitle = (_a = this.config) === null || _a === void 0 ? void 0 : _a.baseTitle;
            const title = baseTitle ? `${helmet.title} ${baseTitle}` : helmet.title;
            this.title.setTitle(title);
        }
        this.applyMetaDefinitions(helmet.metas);
    }
    /**
     * Apply the MetaDefinitions to the document head.
     * If the MetaDefinition has no content, this method will remove the
     * corresponding tag.
     * @param metas The MetaDefinitions to apply to the document.
     */
    applyMetaDefinitions(metas) {
        Object.keys(metas).forEach((selector) => {
            const tag = metas[selector];
            if (!tag.content) {
                this.meta.removeTag(selector);
            }
            else if (this.meta.getTag(selector)) {
                this.meta.updateTag(tag);
            }
            else {
                this.meta.addTag(tag);
            }
        });
    }
}
NgHelmetService.ɵprov = ɵɵdefineInjectable({ factory: function NgHelmetService_Factory() { return new NgHelmetService(ɵɵinject(Title), ɵɵinject(Meta), ɵɵinject(NG_HELMET_CONFIG_TOKEN, 8)); }, token: NgHelmetService, providedIn: "root" });
NgHelmetService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
NgHelmetService.ctorParameters = () => [
    { type: Title },
    { type: Meta },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_HELMET_CONFIG_TOKEN,] }] }
];

let currentId = 0;
class NgHelmetComponent {
    constructor(el, ngHelmetService) {
        this.el = el;
        this.ngHelmetService = ngHelmetService;
        this.id = currentId++;
        this.elId = `ng-helmet-${this.id}`;
        this.destroy$ = new Subject();
    }
    ngAfterContentInit() {
        this.ngHelmetService.pushHelmet(this.id, buildHelmet(this.titles.get(0), this.metas.toArray()));
        combineLatest([
            this.titles.changes,
            this.metas.changes,
        ])
            .pipe(map(([titles, metas]) => buildHelmet(titles.get(0), metas.toArray())), takeUntil(this.destroy$))
            .subscribe((helmet) => this.ngHelmetService.pushHelmet(this.id, helmet));
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.ngHelmetService.popHelmet();
    }
}
NgHelmetComponent.decorators = [
    { type: Component, args: [{
                selector: "ng-helmet",
                template: ``
            },] }
];
NgHelmetComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgHelmetService }
];
NgHelmetComponent.propDecorators = {
    elId: [{ type: HostBinding, args: ["id",] }],
    titles: [{ type: ContentChildren, args: [NgHelmetTitleComponent, {
                    read: ElementRef,
                    emitDistinctChangesOnly: true,
                },] }],
    metas: [{ type: ContentChildren, args: [NgHelmetMetaComponent, {
                    read: ElementRef,
                    emitDistinctChangesOnly: true,
                },] }]
};

const components = [
    NgHelmetComponent,
    NgHelmetTitleComponent,
    NgHelmetMetaComponent,
];
class NgHelmetModule {
    static forRoot(config) {
        return {
            ngModule: NgHelmetModule,
            providers: [{ provide: NG_HELMET_CONFIG_TOKEN, useValue: config }],
        };
    }
}
NgHelmetModule.decorators = [
    { type: NgModule, args: [{
                declarations: components,
                exports: components,
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { NgHelmetComponent, NgHelmetMetaComponent, NgHelmetModule, NgHelmetTitleComponent, NgHelmetService as ɵa, NG_HELMET_CONFIG_TOKEN as ɵb };
//# sourceMappingURL=ng-helmet.js.map
