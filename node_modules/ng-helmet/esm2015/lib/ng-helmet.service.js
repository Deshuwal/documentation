import { __rest } from "tslib";
import { Inject, Injectable, Optional } from "@angular/core";
import { Meta, Title } from "@angular/platform-browser";
import { NG_HELMET_CONFIG_TOKEN } from "./ng-helmet.tokens";
import * as i0 from "@angular/core";
import * as i1 from "@angular/platform-browser";
import * as i2 from "./ng-helmet.tokens";
export class NgHelmetService {
    constructor(title, meta, config) {
        this.title = title;
        this.meta = meta;
        this.config = config;
        this.helmetStack = [];
    }
    /**
     * Push a new helmet on to the helmetStack and update the document head.
     * If the helmet id already exists in the stack (i.e. the ng-helmet content
     * was updated), this method simply updates the helmet at the existing position.
     * @param id The id of the NgHelmetComponent this helmet comes from.
     * @param helmet the NgHelmet data harvested from the component.
     */
    pushHelmet(id, helmet) {
        const index = this.helmetStack.findIndex((e) => e.id === id);
        if (index === -1) {
            this.helmetStack.push({ id, helmet });
        }
        else {
            this.helmetStack[index].helmet = helmet;
        }
        this.applyHelmet(this.computeHelmet());
    }
    /**
     * Pop the top element off the helmetStack and update the document head.
     */
    popHelmet() {
        const top = this.helmetStack.pop();
        if (top) {
            // Drop the content attribute from all top metas so they get cleared.
            const topMetas = top.helmet.metas;
            Object.keys(topMetas).forEach((selector) => {
                const _a = topMetas[selector], { content: _ } = _a, rest = __rest(_a, ["content"]);
                topMetas[selector] = rest;
            });
            // Merge top metas to clear with new computed metas.
            const { title, metas } = this.computeHelmet();
            this.applyHelmet({ title, metas: Object.assign(Object.assign({}, topMetas), metas) });
        }
        else {
            throw new Error(`popped an empty helmetStack`);
        }
    }
    /**
     * Compute the current helmet from the stack.
     * @returns The current helmet.
     */
    computeHelmet() {
        if (this.helmetStack.length > 0) {
            return this.helmetStack
                .map((e) => e.helmet)
                .reduce((acc, el) => {
                var _a;
                return ({
                    title: (_a = el.title) !== null && _a !== void 0 ? _a : acc.title,
                    metas: Object.assign(Object.assign({}, acc.metas), el.metas),
                });
            });
        }
        return { metas: {} };
    }
    /**
     * Apply the given helmet to the document header.
     * @param helmet The helmet to apply.
     */
    applyHelmet(helmet) {
        var _a;
        if (helmet.title) {
            const baseTitle = (_a = this.config) === null || _a === void 0 ? void 0 : _a.baseTitle;
            const title = baseTitle ? `${helmet.title} ${baseTitle}` : helmet.title;
            this.title.setTitle(title);
        }
        this.applyMetaDefinitions(helmet.metas);
    }
    /**
     * Apply the MetaDefinitions to the document head.
     * If the MetaDefinition has no content, this method will remove the
     * corresponding tag.
     * @param metas The MetaDefinitions to apply to the document.
     */
    applyMetaDefinitions(metas) {
        Object.keys(metas).forEach((selector) => {
            const tag = metas[selector];
            if (!tag.content) {
                this.meta.removeTag(selector);
            }
            else if (this.meta.getTag(selector)) {
                this.meta.updateTag(tag);
            }
            else {
                this.meta.addTag(tag);
            }
        });
    }
}
NgHelmetService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgHelmetService_Factory() { return new NgHelmetService(i0.ɵɵinject(i1.Title), i0.ɵɵinject(i1.Meta), i0.ɵɵinject(i2.NG_HELMET_CONFIG_TOKEN, 8)); }, token: NgHelmetService, providedIn: "root" });
NgHelmetService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
NgHelmetService.ctorParameters = () => [
    { type: Title },
    { type: Meta },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_HELMET_CONFIG_TOKEN,] }] }
];
//# sourceMappingURL=ng-helmet.service.js.map